:- module(kb_manager, [
					new_kb/1, release_kb/1, add_axioms/2, run_query/3, %addTAxioms/2, addAAxioms/2 ?
					default_kb/1, clear_kb/1,
					with_read_lock/2, with_write_lock/2
					]).

:- use_module(library(lists)).

:- use_module('../dl_translator/axioms_to_clauses', [axioms_to_clauses/6]).
:- use_module('../prolog_translator/abox_signature', [abox_signature/3]).
:- use_module('../prolog_translator/abox_translator', [abox2prolog/2]).
:- use_module('../prolog_translator/tbox_translator', [tbox2prolog/3]).
:- use_module(query, [query/4]).
:- use_module(config, [target/1, default_kb/1, kb_uri/2, 
				get_dlog_option/3, remove_dlog_options/1,
				abox_module_name/2, tbox_module_name/2, 
				abox_file_name/2, tbox_file_name/2]).
:- target(swi) -> 
	use_module(library(memfile)),
	use_module(core_swi_tools, [datime/1])
	; true.
:- target(sicstus) -> use_module(library(system), [datime/1]) ; true.


:- dynamic current_kb/1,
			kb_count/1.

:- volatile current_kb/1,
			kb_count/1.

%:- default_kb(Def), mutex_create(kb_count), mutex_create(Def).
:- initialization
		assert(kb_count(1)), 
		default_kb(Def), 
		mutex_create(kb_count), 
		mutex_create(Def),
		assert(current_kb(Def)). %initialization?


exists_kb(URI) :-
	nonvar(URI),
	current_kb(URI) -> true
	; throw(no_such_kb).

new_kb(URI) :- 
	with_mutex(kb_count,
	(
		retract(kb_count(ID)),
		ID1 is ID+1, %{<sorszám>|<UUID>}?
		assert(kb_count(ID1))
	)),
	kb_uri(ID, URI),
	mutex_create(URI),
	assert(current_kb(URI)).

release_kb(URI) :-
	with_write_lock(URI,
	(
		clear_kb(URI),
		remove_dlog_options(URI), %beállítások törlése
		retract(current_kb(URI))
	))
	%,mutex_destroy(URI) %TODO
	.

clear_kb(URI) :- 
	with_write_lock(URI,
	(
		tbox_module_name(URI, TB),
		abox_module_name(URI, AB),
		abolish_module(AB),
		abolish_module(TB)		
		%TODO file-ok törlése?
		%, remove_dlog_options(URI) %TODO: beállítások törlése? -> csak default kb-nál
	)).

abolish_module(Module) :-
	current_predicate(Module:P),
	%\+ predicate_property(AB:AP, built_in),
	%\+ predicate_property(AB:AP, imported_from(_Module)),
	%\+ predicate_property(AB:AP, transparent),
	catch(abolish(Module:P), error(permission_error(_,_,_),_), fail),
	fail.
abolish_module(_Module).

add_axioms(URI, axioms(ImpliesCL, ImpliesRL, TransL, ABox)) :- %TODO: eltárolni, hozzáadni
	exists_kb(URI),
	axioms_to_clauses(URI, [ImpliesCL, ImpliesRL, TransL],
			  TBox_Clauses, IBox, HBox, _), %TODO
	abox_signature(ABox, ABoxStr, Signature),
	get_dlog_option(abox_target, URI, ATarget),
	get_dlog_option(tbox_target, URI, TTarget),
	with_write_lock(URI, 
	(	
		add_abox(ATarget, URI, abox(ABoxStr)),
		add_tbox(TTarget, URI, tbox(TBox_Clauses, IBox, HBox), abox(Signature))
	)).

add_abox(tempfile, URI, ABox) :-
	new_memory_file(AMemFile),
	current_output(Out),
	call_cleanup(
		(
			open_memory_file(AMemFile, write, AStream),
			set_output(AStream),
			call_cleanup(
				abox2prolog(URI, ABox), %TODO 
				(set_output(Out), close(AStream))
			),
			open_memory_file(AMemFile, read, AStream2),
			abox_module_name(URI, AB),
			call_cleanup(
				load_files(AB, [stream(AStream2)]), %TODO
				close(AStream2)
			)
		),
		free_memory_file(AMemFile)
	).
add_abox(allinonefile, URI, ABox) :-
	abox_file_name(URI, AFile),
	open(AFile, write, AStream),
	current_output(Out),
	set_output(AStream),
	call_cleanup(
		abox2prolog(URI, ABox), %TODO 
		(set_output(Out), close(AStream))
	),
	load_files(AFile, []). %TODO
add_abox(assert, URI, ABox) :-
	abox2prolog(URI, ABox).


add_tbox(tempfile, URI, TBox, ABox) :-
	new_memory_file(TMemFile),
	current_output(Out),
	call_cleanup(
		(
			open_memory_file(TMemFile, write, TStream),
			set_output(TStream),
			call_cleanup(
				(
					write_tbox_header(URI),
					tbox2prolog(URI, TBox, ABox)
				),
				(set_output(Out), close(TStream))
			),
			open_memory_file(TMemFile, read, TStream2),
			tbox_module_name(URI, TB),
			call_cleanup(
				load_files(TB, [stream(TStream2)]), %TODO
				close(TStream2)
			)
		),
		free_memory_file(TMemFile)
	).
add_tbox(allinonefile, URI, TBox, ABox) :-
	tbox_file_name(URI, TFile),
	open(TFile, write, TStream),
	current_output(Out),
	set_output(TStream),
	call_cleanup(
		(
			write_tbox_header(URI),
			tbox2prolog(URI, TBox, ABox)
		),
		(set_output(Out), close(TStream))
	),
	load_files(TFile, []). %TODO
add_tbox(assert, URI, TBox, ABox) :-
	tbox2prolog(URI, TBox, ABox).


run_query(Query, URI, Answer) :- 
	with_read_lock(URI,
	(
		tbox_module_name(URI, TBox),
		abox_module_name(URI, ABox),
		query(Query, TBox, ABox, Answer)
	)).


write_tbox_header(URI) :-
	datime(datime(Year, Month, Day, Hour, Min, Sec)),
	write('\% Automatically generated by the DLog system.\n'),
	write('\% Budapest University of Technology and Economic (BUTE), 2007.\n'),
	format('\% User defined options: ~p ~n',[todo]),
	format('\% Timestamp: ~d.~d.~d, ~d:~d:~d sec ~n~n',[Year, Month, Day, Hour, Min, Sec]),
	tbox_module_name(URI, MName),
	format(':- module(\'~w\',[]).\n',[MName]),

	%write(':- use_module(library(lists)).\n'),
	%write(':- import(lists:member/2).\n'), %TODO sicstus compatible
	%write(':- require(lists:member/2).\n'),
	%write(':- use_module(hash).\n').
	%write(':- open_resource(dlog_hash, module, H), load_files(dlog_hash, [stream(H)]).\n'),
	write('\n% ************************\n'),
	write(  '% Header\n'),
	write(  '% ************************\n'),
	write('\nsicstus_init :-\n'),
	write('    use_module(library(lists), [member/2]),\n'),
	write('    use_module(hash).\n'),
	write('\nswi_init :-\n'),
	write('    (open_resource(dlog_hash, module, H)\n'),
	write('    ->\n'),
	write('        load_files(dlog_hash, [stream(H)]),\n'),
	write('        import(lists:member/2)\n'),
	write('    ;\n'),
	write('        use_module(hash),\n'),
	write('        use_module(library(lists), [member/2])\n'),
	write('    ).\n'),
	write('\n:- current_predicate(config:target/1)\n'),
	write('    ->\n'),
	write('        (config:target(sicstus) -> sicstus_init ; true),\n'),
	write('        (config:target(swi) -> swi_init ; true)\n'),
	write('    ;\n'),
	write('        (current_prolog_flag(dialect, swi) -> swi_init\n'),
	write('        ; %current_prolog_flag(language, sicstus) %sicstus/iso\n'),
	write('            sicstus_init\n'),
	write('        ).\n\n').


get_read_lock(URI) :-
	exists_kb(URI), %don't create if not exists
	mutex_lock(URI),
	exists_kb(URI). %check if still existing
get_write_lock(URI) :-
	exists_kb(URI), 
	mutex_lock(URI),
	exists_kb(URI).
release_read_lock(URI) :-
	mutex_unlock(URI).
release_write_lock(URI) :-
	mutex_unlock(URI).
with_read_lock(URI, Goal) :-
	exists_kb(URI), 
	with_mutex(URI, (exists_kb(URI),Goal)).
with_write_lock(URI, Goal) :-
	exists_kb(URI), 
	with_mutex(URI, (exists_kb(URI),Goal)).
